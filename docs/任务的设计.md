# Agent2Agent (A2A) 协议详解

## 1. 协议核心概念翻译与解释

### 基础交互方式
**翻译：**
在Agent2Agent (A2A) 协议中，交互范围可以从简单的无状态交换到复杂的长期运行过程。当代理从客户端收到消息时，它可以通过以下两种基本方式之一进行响应：

1. **用无状态消息响应**：此类响应通常用于即时、自包含的交互，这些交互无需进一步的状态管理即可结束。
2. **启动有状态任务**：如果响应是任务，代理将通过定义的生命周期处理它，根据需要沟通进度和请求输入，直到达到中断状态（例如，需要输入、需要授权）或终端状态（例如，完成、取消、拒绝、失败）。

**解释：**
A2A协议定义了代理（智能体）之间或客户端与代理之间交互的两种模式：
- **无状态消息**：像一次性问答，完成后不留下需要跟踪的状态。适合简单查询。
- **有状态任务**：像启动一个工作流，有开始、进行中、可能暂停、最终结束等多个状态。代理会持续更新任务状态，客户端可以监控进度并在需要时提供输入。

### 上下文分组
**翻译：**
`contextId`是一个关键标识符，它在逻辑上将多个任务对象和独立的消息对象分组，为一系列交互提供连续性。

- 当客户端首次发送消息时，代理会响应一个新的`contextId`。如果启动了任务，它还会有一个`taskId`。
- 客户端可以发送后续消息并包含相同的`contextId`，以表明它们正在同一上下文中继续之前的交互。
- 客户端可选择将`taskId`附加到后续消息中，以表明它继续该特定任务。

`contextId`支持为共同目标或跨多个可能并发的任务的共享上下文会话进行协作。在内部，A2A代理（特别是使用LLM的代理）使用`contextId`来管理其内部会话状态或其LLM上下文。

**解释：**
- **`contextId` (上下文ID)**：像一个“会话ID”或“项目ID”，将围绕同一主题或目标的所有交互绑定在一起。即使有多个独立的任务，只要属于同一件“事”，就共享一个`contextId`。
- **`taskId` (任务ID)**：标识一个具体的、有状态的任务实例。
- **设计目的**：保持对话或工作的连贯性。例如，在一个设计项目中（一个`contextId`），可能有“生成草图”（一个`taskId`）和“渲染效果图”（另一个`taskId`）等多个任务。

### 代理响应类型
**翻译：**
选择用**消息**还是**任务**响应取决于交互的性质和代理的能力：

- **用于简单交互的消息**：消息对象适用于不需要长时间处理或复杂状态管理的事务性交互。代理可能使用消息来协商任务的接受或范围，然后再提交任务对象。
- **用于有状态交互的任务**：一旦代理将传入消息的意图映射到需要大量、可跟踪工作并持续较长时间的支持能力上，代理就会用任务对象进行响应。

**解释：**
代理根据自身复杂度和交互需求分为三类：
1. **仅消息代理**：总是返回消息对象。它们通常不管理复杂状态或长时间运行，使用`contextId`将消息关联起来。可能直接包装LLM调用和简单工具。
2. **仅任务代理**：总是返回任务对象，即使是简单响应也建模为“已完成”的任务。一旦任务创建，代理将只返回任务对象来响应发送的消息；一旦任务完成，就不能再发送消息。这种方法避免了决定用任务还是消息的纠结，但会为简单交互也创建已完成的任务对象。
3. **混合代理**：生成消息和任务对象。这些代理使用消息来协商代理能力和任务工作范围，然后发送任务对象来跟踪执行并管理状态（如需要输入、错误处理）。一旦任务创建，代理将只返回任务对象来响应发送的消息；一旦任务完成，就不能再发送消息。

**核心区别**：
- **消息**：简单、快速、无状态。用于问答、协商、确认。
- **任务**：复杂、有状态、可跟踪。用于需要时间、分步骤、可能暂停等待输入的工作。

### 任务细化与不可变性
**翻译：**
**任务细化**
客户端经常需要根据任务结果发送新请求或细化先前任务的输出。这通过使用与原始任务相同的`contextId`开始另一个交互来建模。客户端还通过在消息对象中提供`referenceTaskIds`来进一步向代理提示。然后代理用新任务或消息进行响应。

**任务不可变性**
一旦任务达到终端状态（完成、取消、拒绝或失败），它就不能重新启动。任何与该任务相关的后续交互，例如细化，必须在相同的`contextId`内启动一个新任务。这一原则提供了几个好处：
- **任务不可变性**：客户端可以可靠地引用任务及其关联的状态、工件和消息，提供清晰的输入到输出映射。这对编排和可追溯性很有价值。
- **清晰的工作单元**：每个新请求、细化或后续操作都成为一个独立的任务。这简化了簿记，允许对代理的工作进行精细跟踪，并使得每个工件都能追溯到特定的工作单元。
- **更容易实现**：这消除了代理开发者在是创建新任务还是重新启动现有任务问题上的歧义。

**解释：**
- **任务细化**：用户看了任务结果后说“改一下这里”，这就是细化。它通过引用旧任务的ID (`referenceTaskIds`) 并保持在同一个上下文 (`contextId`) 中来实现。
- **任务不可变原则**：任务一旦结束（无论成功失败），就是历史记录，不可更改。要修改或基于其结果做新事，必须创建**新任务**。这就像Git提交，每次修改都是一个新的提交，历史清晰可查。
- **好处**：
  - **可追溯性**：每个任务都有明确的输入和输出。
  - **简单性**：代理不用处理“重启任务”这种复杂逻辑。
  - **清晰度**：每个`taskId`对应一个明确的工作单元。

### 并行跟进
**翻译：**
A2A通过允许代理在同一`contextId`内为每个发送的跟进消息创建独立的并行任务来支持并行工作。这使得客户端能够跟踪单个任务，并在先决任务完成后立即创建新的依赖任务。

例如：
1. 任务1：预订飞往赫尔辛基的航班。
2. 任务2：基于任务1，预订酒店。
3. 任务3：基于任务1，预订雪地摩托活动。
4. 任务4：基于任务2，为酒店预订添加水疗预约。

**解释：**
协议支持**工作流并行化**。在同一个大项目（`contextId`）下，可以同时进行多个任务。任务之间可以有依赖关系（如任务2依赖任务1完成）。客户端可以管理这些依赖关系，一旦某个任务完成，就触发依赖于它的后续任务。

### 引用先前工件与追踪变更
**翻译：**
**引用先前工件**
服务代理从引用的任务或`contextId`中推断相关工件。作为领域专家，服务代理最适合解决歧义或识别缺失信息。如果存在歧义，代理会通过返回“需要输入”状态向客户端请求澄清。然后客户端在其响应中指定工件，可选择在部件元数据中填充工件引用（`artifactId`, `taskId`）。

**追踪工件变更**
跟进或细化任务通常会导致基于旧工件创建新工件。追踪这些变更对于确保在后续交互中仅使用工件的最新版本非常重要。这可以被概念化为版本历史，其中每个新工件都链接到其前身。

然而，客户端是管理这种工件链接的最佳位置。客户端决定什么构成可接受的结果，并能够接受或拒绝新版本。因此，服务代理不应负责追踪工件变更，这种链接不属于A2A协议规范的一部分。客户端应在其端维护此版本历史，并向用户呈现最新的可接受版本。

为方便客户端追踪，服务代理在生成现有工件的细化版本时应使用一致的`artifact-name`。

当启动跟进或细化任务时，客户端应明确引用他们打算细化的特定工件，理想情况下是从他们角度来看的“最新”版本。如果未提供工件引用，服务代理可以：
1. 尝试根据当前`contextId`推断预期的工件。
2. 如果存在歧义或上下文不足，代理应响应“需要输入”的任务状态以向客户端请求澄清。

**解释：**
- **工件 (Artifact)**：任务产生的结果，如图片、文档、数据等。
- **工件引用**：当用户说“把上一个图改成红色”，代理需要知道“上一个图”具体是哪个`artifactId`。用户可以通过`referenceTaskIds`来暗示，或直接提供`artifactId`。
- **版本管理客户端负责**：协议本身不强制维护工件的版本链（如v1, v2, v3）。这是为了简化代理实现。
- **代理的责任**：
  - 如果收到细化请求，尽可能推断用户指的是哪个旧工件。
  - 如果推断不出（例如上下文中有多个可能的图片），就暂停任务，向用户询问更多信息（返回`input-required`状态）。
  - 生成新版本时，保持`name`字段一致（如都是`sailboat_image.png`），但`artifactId`必须是新的。
- **客户端的责任**：
  - 自己维护工件的版本历史树。
  - 知道哪个是最新版本、哪个是用户最终接受的版本。
  - 在发起新请求时，明确告诉代理要基于哪个版本进行修改（通过提供具体的`artifactId`引用）。

## 2. 示例场景逐步分析

### 初始请求
**客户端发送：**
```json
{
  "jsonrpc": "2.0",
  "id": "req-001",
  "method": "message.send",
  "params": {
    "message": {
      "role": "user",
      "parts": [
        {"text": "Generate an image of a sailboat on the ocean."}
      ],
      "messageId": "msg-user-001"
    }
  }
}
```
**分析：**
- 这是一个简单的消息发送请求。
- 没有提供`contextId`，表示这是对话的开始。
- `messageId`是客户端生成的消息标识。

### 代理响应（任务完成）
**代理响应：**
```json
{
  "jsonrpc": "2.0",
  "id": "req-001",
  "result": {
    "id": "task-boat-gen-123",
    "contextId": "ctx-conversation-abc",
    "status": {"state": "completed"},
    "artifacts": [
      {
        "artifactId": "artifact-boat-v1-xyz",
        "name": "sailboat_image.png",
        "description": "A generated image of a sailboat on the ocean.",
        "parts": [
          {
            "file": {
              "name": "sailboat_image.png",
              "mediaType": "image/png",
              "fileWithBytes": "base64_encoded_png_data_of_a_sailboat"
            }
          }
        ]
      }
    ]
  }
}
```
**分析：**
- 代理没有用简单消息回复，而是创建了一个**任务**，表明这是一个有状态的操作。
- 代理生成了新的`contextId: "ctx-conversation-abc"`，后续所有相关交互都应使用此ID。
- 任务状态为`completed`，表示已成功完成。
- 任务产生了一个**工件**（图片），有唯一的`artifactId: "artifact-boat-v1-xyz"`。
- 图片数据以Base64编码嵌入在响应中。

### 细化请求
**客户端发送：**
```json
{
  "jsonrpc": "2.0",
  "id": "req-002",
  "method": "message.send",
  "params": {
    "message": {
      "role": "user",
      "messageId": "msg-user-002",
      "contextId": "ctx-conversation-abc",
      "referenceTaskIds": ["task-boat-gen-123"],
      "parts": [
        {"text": "Please modify the sailboat to be red."}
      ]
    }
  }
}
```
**分析：**
- 客户端使用了之前获得的`contextId: "ctx-conversation-abc"`，表明这是同一对话的继续。
- `referenceTaskIds: ["task-boat-gen-123"]`明确告诉代理：“请基于任务`task-boat-gen-123`的结果进行修改”。
- 消息内容是细化请求：“把帆船改成红色”。

### 代理响应（新任务完成）
**代理响应：**
```json
{
  "jsonrpc": "2.0",
  "id": "req-002",
  "result": {
    "id": "task-boat-color-456",
    "contextId": "ctx-conversation-abc",
    "status": {"state": "completed"},
    "artifacts": [
      {
        "artifactId": "artifact-boat-v2-red-pqr",
        "name": "sailboat_image.png",
        "description": "A generated image of a red sailboat on the ocean.",
        "parts": [
          {
            "file": {
              "name": "sailboat_image.png",
              "mediaType": "image/png",
              "fileWithBytes": "base64_encoded_png_data_of_a_RED_sailboat"
            }
          }
        ]
      }
    ]
  }
}
```
**分析：**
- 代理创建了**新任务**`task-boat-color-456`（遵循任务不可变原则）。
- 使用了相同的`contextId: "ctx-conversation-abc"`，保持上下文一致。
- 创建了**新工件**`artifact-boat-v2-red-pqr`，但保持了相同的`name: "sailboat_image.png"`（方便客户端识别这是同一文件的更新版本）。
- 描述更新为“红色帆船”。

## 3. 协议设计要点总结

### 核心设计思想
1. **状态分离**：无状态消息用于简单交互，有状态任务用于复杂工作流。
2. **上下文绑定**：`contextId`将相关交互分组，`taskId`标识具体工作单元。
3. **任务不可变**：已完成任务作为历史记录，任何修改都创建新任务。
4. **客户端管理版本**：客户端负责维护工件版本历史和引用关系。

### 工作流程特点
- **灵活响应**：代理可根据情况选择返回消息或创建任务。
- **明确引用**：通过`referenceTaskIds`和`artifactId`明确指定依赖关系。
- **状态驱动**：任务生命周期明确，支持暂停等待输入(`input-required`)。
- **并行支持**：同一上下文中可并行多个任务，支持依赖关系。

### 实现考虑
- **代理类型选择**：开发者可根据需求实现消息型、任务型或混合型代理。
- **状态管理**：代理需维护与`contextId`相关的会话状态。
- **错误处理**：通过任务状态（如`failed`）和消息协商处理异常。
- **可扩展性**：支持复杂工作流和并行处理。

该协议适用于需要智能代理协作的系统，如自动化工作流、AI助手集成、复杂任务分解等场景，提供了结构化、可追踪的交互框架。
